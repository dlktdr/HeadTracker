/*
* This file is part of the Head Tracker distribution (https://github.com/dlktdr/headtracker)
* Copyright (c) 2022 Cliff Blackburn
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, version 3.
*
* This program is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
* General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>.
*/

/**********************************************
 *
 *  !!! THIS FILE IS AUTOMATICALLY GENERATED, DO NOT EDIT DIRECTLY !!!
 *
 *  Modify /utils/settings.csv and execute buildsettings.py to generate this FW header
 *
 ***********************************************/

#pragma once

#include <stdint.h>
#include <string.h>
#include <math.h>

#include "arduinojsonwrp.h"

extern unsigned int encode_base64(unsigned char input[], unsigned int input_length,
                           unsigned char output[]);

class BaseTrackerSettings {
public:
  static constexpr float FLOAT_MIN = -1000000;
  static constexpr float FLOAT_MAX = 1000000;
  static constexpr uint16_t MIN_PWM = 988;
  static constexpr uint16_t MAX_PWM = 2012;
  static constexpr uint16_t DEF_MIN_PWM = 1050;
  static constexpr uint16_t DEF_MAX_PWM = 1950;
  static constexpr uint16_t PPM_CENTER = 1500;
  static constexpr float MIN_GAIN = 0.01;
  static constexpr float MAX_GAIN = 35;
  static constexpr uint16_t MINMAX_RNG = 487;
  static constexpr uint16_t MIN_TO_CENTER = 25;
  static constexpr uint16_t MIN_CNT = (((MAX_PWM - MIN_PWM) / 2) + MIN_PWM - MINMAX_RNG);
  static constexpr uint16_t MAX_CNT = (((MAX_PWM - MIN_PWM) / 2) + MIN_PWM + MINMAX_RNG);
  static constexpr uint8_t BT_CHANNELS = 8;
  static constexpr uint8_t MAX_CHANNELS = 16;
  static constexpr uint8_t AUX_FUNCTIONS = 7;
  static constexpr uint8_t TILT_REVERSE_BIT = 1;
  static constexpr uint8_t ROLL_REVERSE_BIT = 2;
  static constexpr uint8_t PAN_REVERSE_BIT = 4;
  static constexpr uint16_t SBUS_CENTER = 992;
  static constexpr float SBUS_SCALE = 1.6;
  static constexpr float RESET_ON_TILT_TIME = 1.5;
  static constexpr float RESET_ON_TILT_AFTER = 1;
  static constexpr float RECENTER_PULSE_DURATION = 0.5;
  static constexpr float UART_ACTIVE_TIME = 0.1;
  static constexpr float PPM_MIN_FRAMESYNC = 3000;
  static constexpr float PPM_MIN_FRAME = 6666;
  static constexpr float PPM_MAX_FRAME = 40000;
  static constexpr uint8_t UART_MODE_OFF = 0;
  static constexpr uint8_t UART_MODE_SBUS = 1;
  static constexpr uint8_t UART_MODE_CRSFIN = 2;
  static constexpr uint8_t UART_MODE_CRSFOUT = 3;

  BaseTrackerSettings() {
    strcpy(btpairedaddress,"");
    memset(chout,0,sizeof(uint16_t) * 16);
    memset(btch,0,sizeof(uint16_t) * 8);
    memset(ppmch,0,sizeof(uint16_t) * 16);
    memset(uartch,0,sizeof(uint16_t) * 16);
    memset(quat,0,sizeof(float) * 4);
    memset(btaddr,0,sizeof(char) * 18);
    memset(btrmt,0,sizeof(char) * 18);

    // Call Virtual Events after initialization
    pinsChanged();
    resetFusion();
  }

  // Virtual Events
  virtual void pinsChanged() {};
  virtual void resetFusion() {};

  // Roll Minimum
  inline const uint16_t& getRll_Min() {return rll_min;}
  bool setRll_Min(uint16_t val=DEF_MIN_PWM) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      rll_min = val;
      return true;
    }
    return false;
  }

  // Roll Maximum
  inline const uint16_t& getRll_Max() {return rll_max;}
  bool setRll_Max(uint16_t val=DEF_MAX_PWM) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      rll_max = val;
      return true;
    }
    return false;
  }

  // Roll Center
  inline const uint16_t& getRll_Cnt() {return rll_cnt;}
  bool setRll_Cnt(uint16_t val=PPM_CENTER) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      rll_cnt = val;
      return true;
    }
    return false;
  }

  // Roll Gain
  inline const float& getRll_Gain() {return rll_gain;}
  bool setRll_Gain(float val=5) {
    if(val >= MIN_GAIN && val <= MAX_GAIN) {
      rll_gain = val;
      return true;
    }
    return false;
  }

  // Tilt Minimum
  inline const uint16_t& getTlt_Min() {return tlt_min;}
  bool setTlt_Min(uint16_t val=DEF_MIN_PWM) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      tlt_min = val;
      return true;
    }
    return false;
  }

  // Tilt Maximum
  inline const uint16_t& getTlt_Max() {return tlt_max;}
  bool setTlt_Max(uint16_t val=DEF_MAX_PWM) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      tlt_max = val;
      return true;
    }
    return false;
  }

  // Tilt Center
  inline const uint16_t& getTlt_Cnt() {return tlt_cnt;}
  bool setTlt_Cnt(uint16_t val=PPM_CENTER) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      tlt_cnt = val;
      return true;
    }
    return false;
  }

  // Tilt Gain
  inline const float& getTlt_Gain() {return tlt_gain;}
  bool setTlt_Gain(float val=5) {
    if(val >= MIN_GAIN && val <= MAX_GAIN) {
      tlt_gain = val;
      return true;
    }
    return false;
  }

  // Pan Minimum
  inline const uint16_t& getPan_Min() {return pan_min;}
  bool setPan_Min(uint16_t val=DEF_MIN_PWM) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      pan_min = val;
      return true;
    }
    return false;
  }

  // Pan Maximum
  inline const uint16_t& getPan_Max() {return pan_max;}
  bool setPan_Max(uint16_t val=DEF_MAX_PWM) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      pan_max = val;
      return true;
    }
    return false;
  }

  // Pan Center
  inline const uint16_t& getPan_Cnt() {return pan_cnt;}
  bool setPan_Cnt(uint16_t val=PPM_CENTER) {
    if(val >= MIN_PWM && val <= MAX_PWM) {
      pan_cnt = val;
      return true;
    }
    return false;
  }

  // Pan Gain
  inline const float& getPan_Gain() {return pan_gain;}
  bool setPan_Gain(float val=5) {
    if(val >= MIN_GAIN && val <= MAX_GAIN) {
      pan_gain = val;
      return true;
    }
    return false;
  }

  // Tilt Output Channel
  inline const int8_t& getTltCh() {return tltch;}
  bool setTltCh(int8_t val=-1) {
    if(val >= -1 && val <= MAX_CHANNELS) {
      tltch = val;
      return true;
    }
    return false;
  }

  // Roll Output Channel
  inline const int8_t& getRllCh() {return rllch;}
  bool setRllCh(int8_t val=-1) {
    if(val >= -1 && val <= MAX_CHANNELS) {
      rllch = val;
      return true;
    }
    return false;
  }

  // Pan Output Channel
  inline const int8_t& getPanCh() {return panch;}
  bool setPanCh(int8_t val=-1) {
    if(val >= -1 && val <= MAX_CHANNELS) {
      panch = val;
      return true;
    }
    return false;
  }

  // Alert Output Channel
  inline const int8_t& getAlertCh() {return alertch;}
  bool setAlertCh(int8_t val=-1) {
    if(val >= -1 && val <= MAX_CHANNELS) {
      alertch = val;
      return true;
    }
    return false;
  }

  // PWM 0 Channel
  inline const int8_t& getPwm0() {return pwm0;}
  bool setPwm0(int8_t val=-1) {
    if(val >= -1 && val <= MAX_CHANNELS) {
      pwm0 = val;
      return true;
    }
    return false;
  }

  // PWM 1 Channel
  inline const int8_t& getPwm1() {return pwm1;}
  bool setPwm1(int8_t val=-1) {
    if(val >= -1 && val <= MAX_CHANNELS) {
      pwm1 = val;
      return true;
    }
    return false;
  }

  // PWM 2 Channel
  inline const int8_t& getPwm2() {return pwm2;}
  bool setPwm2(int8_t val=-1) {
    if(val >= -1 && val <= MAX_CHANNELS) {
      pwm2 = val;
      return true;
    }
    return false;
  }

  // PWM 3 Channel
  inline const int8_t& getPwm3() {return pwm3;}
  bool setPwm3(int8_t val=-1) {
    if(val >= -1 && val <= MAX_CHANNELS) {
      pwm3 = val;
      return true;
    }
    return false;
  }

  // Analog 0 Channel
  inline const int8_t& getAn0Ch() {return an0ch;}
  bool setAn0Ch(int8_t val=-1) {
    if(val >= -1 && val <= MAX_CHANNELS) {
      an0ch = val;
      return true;
    }
    return false;
  }

  // Analog 1 Channel
  inline const int8_t& getAn1Ch() {return an1ch;}
  bool setAn1Ch(int8_t val=-1) {
    if(val >= -1 && val <= MAX_CHANNELS) {
      an1ch = val;
      return true;
    }
    return false;
  }

  // Analog 2 Channel
  inline const int8_t& getAn2Ch() {return an2ch;}
  bool setAn2Ch(int8_t val=-1) {
    if(val >= -1 && val <= MAX_CHANNELS) {
      an2ch = val;
      return true;
    }
    return false;
  }

  // Analog 3 Channel
  inline const int8_t& getAn3Ch() {return an3ch;}
  bool setAn3Ch(int8_t val=-1) {
    if(val >= -1 && val <= MAX_CHANNELS) {
      an3ch = val;
      return true;
    }
    return false;
  }

  // Auxilary Function 0 Channel
  inline const int8_t& getAux0Ch() {return aux0ch;}
  bool setAux0Ch(int8_t val=-1) {
    if(val >= -1 && val <= MAX_CHANNELS) {
      aux0ch = val;
      return true;
    }
    return false;
  }

  // Auxilary Function 1 Channel
  inline const int8_t& getAux1Ch() {return aux1ch;}
  bool setAux1Ch(int8_t val=-1) {
    if(val >= -1 && val <= MAX_CHANNELS) {
      aux1ch = val;
      return true;
    }
    return false;
  }

  // Auxilary Function 2 Channel
  inline const int8_t& getAux2Ch() {return aux2ch;}
  bool setAux2Ch(int8_t val=-1) {
    if(val >= -1 && val <= MAX_CHANNELS) {
      aux2ch = val;
      return true;
    }
    return false;
  }

  // Reset Center on PPM Input Channel
  inline const int8_t& getRstPpm() {return rstppm;}
  bool setRstPpm(int8_t val=-1) {
    if(val >= -1 && val <= MAX_CHANNELS) {
      rstppm = val;
      return true;
    }
    return false;
  }

  // Auxilary Function 0
  inline const uint8_t& getAux0Func() {return aux0func;}
  bool setAux0Func(uint8_t val=0) {
    if(val >= 0 && val <= AUX_FUNCTIONS) {
      aux0func = val;
      return true;
    }
    return false;
  }

  // Auxilary Function 1
  inline const uint8_t& getAux1Func() {return aux1func;}
  bool setAux1Func(uint8_t val=0) {
    if(val >= 0 && val <= AUX_FUNCTIONS) {
      aux1func = val;
      return true;
    }
    return false;
  }

  // Auxilary Function 2
  inline const uint8_t& getAux2Func() {return aux2func;}
  bool setAux2Func(uint8_t val=0) {
    if(val >= 0 && val <= AUX_FUNCTIONS) {
      aux2func = val;
      return true;
    }
    return false;
  }

  // Analog 0 Gain
  inline const float& getAn0Gain() {return an0gain;}
  bool setAn0Gain(float val=310) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      an0gain = val;
      return true;
    }
    return false;
  }

  // Analog 1 Gain
  inline const float& getAn1Gain() {return an1gain;}
  bool setAn1Gain(float val=310) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      an1gain = val;
      return true;
    }
    return false;
  }

  // Analog 2 Gain
  inline const float& getAn2Gain() {return an2gain;}
  bool setAn2Gain(float val=310) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      an2gain = val;
      return true;
    }
    return false;
  }

  // Analog 3 Gain
  inline const float& getAn3Gain() {return an3gain;}
  bool setAn3Gain(float val=310) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      an3gain = val;
      return true;
    }
    return false;
  }

  // Analog 0 Offset
  inline const float& getAn0Off() {return an0off;}
  bool setAn0Off(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      an0off = val;
      return true;
    }
    return false;
  }

  // Analog 1 Offset
  inline const float& getAn1Off() {return an1off;}
  bool setAn1Off(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      an1off = val;
      return true;
    }
    return false;
  }

  // Analog 2 Offset
  inline const float& getAn2Off() {return an2off;}
  bool setAn2Off(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      an2off = val;
      return true;
    }
    return false;
  }

  // Analog 3 Offset
  inline const float& getAn3Off() {return an3off;}
  bool setAn3Off(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      an3off = val;
      return true;
    }
    return false;
  }

  // Servo Reverse (BitMask)
  inline const uint8_t& getServoReverse() {return servoreverse;}
  bool setServoReverse(uint8_t val=0) {
    if(val >= 0 && val <= 7) {
      servoreverse = val;
      return true;
    }
    return false;
  }

  // Magnetometer X Calibration Offset
  inline const float& getMagXOff() {return magxoff;}
  bool setMagXOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      magxoff = val;
      return true;
    }
    return false;
  }

  // Magnetometer Y Calibration Offset
  inline const float& getMagYOff() {return magyoff;}
  bool setMagYOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      magyoff = val;
      return true;
    }
    return false;
  }

  // Magnetometer Z Calibration Offset
  inline const float& getMagZOff() {return magzoff;}
  bool setMagZOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      magzoff = val;
      return true;
    }
    return false;
  }

  // Accelerometer X Calibration Offset
  inline const float& getAccXOff() {return accxoff;}
  bool setAccXOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      accxoff = val;
      return true;
    }
    return false;
  }

  // Accelerometer Y Calibration Offset
  inline const float& getAccYOff() {return accyoff;}
  bool setAccYOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      accyoff = val;
      return true;
    }
    return false;
  }

  // Accelerometer Z Calibration Offset
  inline const float& getAccZOff() {return acczoff;}
  bool setAccZOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      acczoff = val;
      return true;
    }
    return false;
  }

  // Gyrometer X Calibration Offset
  inline const float& getGyrXOff() {return gyrxoff;}
  bool setGyrXOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      gyrxoff = val;
      return true;
    }
    return false;
  }

  // Gyrometer Y Calibration Offset
  inline const float& getGyrYOff() {return gyryoff;}
  bool setGyrYOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      gyryoff = val;
      return true;
    }
    return false;
  }

  // Gyrometer Z Calibration Offset
  inline const float& getGyrZOff() {return gyrzoff;}
  bool setGyrZOff(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      gyrzoff = val;
      return true;
    }
    return false;
  }

  // Soft Iron Offset 00
  inline const float& getso00() {return so00;}
  bool setso00(float val=1) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      so00 = val;
      return true;
    }
    return false;
  }

  // Soft Iron Offset 01
  inline const float& getso01() {return so01;}
  bool setso01(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      so01 = val;
      return true;
    }
    return false;
  }

  // Soft Iron Offset 02
  inline const float& getso02() {return so02;}
  bool setso02(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      so02 = val;
      return true;
    }
    return false;
  }

  // Soft Iron Offset 10
  inline const float& getso10() {return so10;}
  bool setso10(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      so10 = val;
      return true;
    }
    return false;
  }

  // Soft Iron Offset 11
  inline const float& getso11() {return so11;}
  bool setso11(float val=1) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      so11 = val;
      return true;
    }
    return false;
  }

  // Soft Iron Offset 12
  inline const float& getso12() {return so12;}
  bool setso12(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      so12 = val;
      return true;
    }
    return false;
  }

  // Soft Iron Offset 20
  inline const float& getso20() {return so20;}
  bool setso20(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      so20 = val;
      return true;
    }
    return false;
  }

  // Soft Iron Offset 21
  inline const float& getso21() {return so21;}
  bool setso21(float val=0) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      so21 = val;
      return true;
    }
    return false;
  }

  // Soft Iron Offset 22
  inline const float& getso22() {return so22;}
  bool setso22(float val=1) {
    if(val >= FLOAT_MIN && val <= FLOAT_MAX) {
      so22 = val;
      return true;
    }
    return false;
  }

  // Disable Magnetometer
  inline const bool& getDisMag() {return dismag;}
  void setDisMag(bool val=1) { dismag = val; }

  // Board Rotation X
  inline const float& getRotX() {return rotx;}
  bool setRotX(float val=0) {
    if(val >= -360 && val <= 360) {
      rotx = val;
      return true;
    }
    return false;
  }

  // Board Rotation Y
  inline const float& getRotY() {return roty;}
  bool setRotY(float val=0) {
    if(val >= -360 && val <= 360) {
      roty = val;
      return true;
    }
    return false;
  }

  // Board Rotation Z
  inline const float& getRotZ() {return rotz;}
  bool setRotZ(float val=0) {
    if(val >= -360 && val <= 360) {
      rotz = val;
      return true;
    }
    return false;
  }

  // Button Pin
  inline const int8_t& getButtonPin() {return buttonpin;}
  bool setButtonPin(int8_t val=2) {
    if(val >= -1 && val <= 64) {
      buttonpin = val;
      return true;
    }
    return false;
  }

  // PPM Output Pin
  inline const int8_t& getPpmOutPin() {return ppmoutpin;}
  bool setPpmOutPin(int8_t val=10) {
    if(val >= -1 && val <= 64) {
      ppmoutpin = val;
      return true;
    }
    return false;
  }

  // PPM Input Pin
  inline const int8_t& getPpmInPin() {return ppminpin;}
  bool setPpmInPin(int8_t val=-1) {
    if(val >= -1 && val <= 64) {
      ppminpin = val;
      return true;
    }
    return false;
  }

  // Uart Mode (0- Off, 1-SBUS, 2-CRSFIN, 3-CRSFOUT)
  inline const uint8_t& getUartMode() {return uartmode;}
  bool setUartMode(uint8_t val=0) {
    if(val >= 0 && val <= 3) {
      uartmode = val;
      return true;
    }
    return false;
  }

  // CRSF Transmit Frequncy
  inline const uint8_t& getCrsfTxRate() {return crsftxrate;}
  bool setCrsfTxRate(uint8_t val=140) {
    if(val >= 30 && val <= 140) {
      crsftxrate = val;
      return true;
    }
    return false;
  }

  // SBUS Transmit Freqency
  inline const uint8_t& getSbusTxRate() {return sbustxrate;}
  bool setSbusTxRate(uint8_t val=80) {
    if(val >= 30 && val <= 140) {
      sbustxrate = val;
      return true;
    }
    return false;
  }

  // SBUS Receieve Inverted
  inline const bool& getSbInInv() {return sbininv;}
  void setSbInInv(bool val=true) { sbininv = val; }

  // SBUS Transmit Inverted
  inline const bool& getSbOutInv() {return sboutinv;}
  void setSbOutInv(bool val=true) { sboutinv = val; }

  // Invert CRSF output
  inline const bool& getCrsfTxInv() {return crsftxinv;}
  void setCrsfTxInv(bool val=false) { crsftxinv = val; }

  // Channel 5 
  inline const bool& getCh5Arm() {return ch5arm;}
  void setCh5Arm(bool val=false) { ch5arm = val; }

  // Bluetooth Mode (0-Off, 1- Head, 2-Receive, 3-Scanner)
  inline const uint8_t& getBtMode() {return btmode;}
  bool setBtMode(uint8_t val=0) {
    if(val >= 0 && val <= 3) {
      btmode = val;
      return true;
    }
    return false;
  }

  // Reset on Proximity Sense
  inline const bool& getRstOnWave() {return rstonwave;}
  void setRstOnWave(bool val=false) { rstonwave = val; }

  // Long Press on the Button to Enable/Disable Tilt Roll and Pan
  inline const bool& getButLngPs() {return butlngps;}
  void setButLngPs(bool val=false) { butlngps = val; }

  // Reset Center on a Head Tilt
  inline const bool& getRstOnTlt() {return rstontlt;}
  void setRstOnTlt(bool val=false) { rstontlt = val; }

  // Invert PPM Output
  inline const bool& getPpmOutInvert() {return ppmoutinvert;}
  void setPpmOutInvert(bool val=false) { ppmoutinvert = val; }

  // Invert PPM Output
  inline const bool& getPpmInInvert() {return ppmininvert;}
  void setPpmInInvert(bool val=false) { ppmininvert = val; }

  // PPM Frame Length (us)
  inline const uint16_t& getPpmFrame() {return ppmframe;}
  bool setPpmFrame(uint16_t val=22500) {
    if(val >= PPM_MIN_FRAME && val <= PPM_MAX_FRAME) {
      ppmframe = val;
      return true;
    }
    return false;
  }

  // PPM Sync Pulse Length (us)
  inline const uint16_t& getPpmSync() {return ppmsync;}
  bool setPpmSync(uint16_t val=350) {
    if(val >= 100 && val <= 800) {
      ppmsync = val;
      return true;
    }
    return false;
  }

  // PPM channels to output
  inline const uint8_t& getPpmChCnt() {return ppmchcnt;}
  bool setPpmChCnt(uint8_t val=8) {
    if(val >= 1 && val <= 16) {
      ppmchcnt = val;
      return true;
    }
    return false;
  }

  // Bluetooth Remote address to Pair With
  void getBtPairedAddress(char* dest) {strcpy(dest, btpairedaddress);}
  void setBtPairedAddress(const char *val) {
    strncpy(btpairedaddress, val, 17+1);
    btpairedaddress[17] = '\0';
  }

  // Raw Sensor Mag X
  void setDataMagX(float val) { magx = val; }

  // Raw Sensor Mag Y
  void setDataMagY(float val) { magy = val; }

  // Raw Sensor Mag Z
  void setDataMagZ(float val) { magz = val; }

  // Raw Sensor Gyro X
  void setDataGyroX(float val) { gyrox = val; }

  // Raw Sensor Gyro Y
  void setDataGyroY(float val) { gyroy = val; }

  // Raw Sensor Gyro Z
  void setDataGyroZ(float val) { gyroz = val; }

  // Raw Sensor Accel X
  void setDataAccX(float val) { accx = val; }

  // Raw Sensor Accel Y
  void setDataAccY(float val) { accy = val; }

  // Raw Sensor Accel Z
  void setDataAccZ(float val) { accz = val; }

  // Calibrated Mag X
  void setDataOff_MagX(float val) { off_magx = val; }

  // Calibrated Mag Y
  void setDataOff_MagY(float val) { off_magy = val; }

  // Calibrated Mag Z
  void setDataOff_MagZ(float val) { off_magz = val; }

  // Calibrated Gyro X
  void setDataOff_GyroX(float val) { off_gyrox = val; }

  // Calibrated Gyro Y
  void setDataOff_GyroY(float val) { off_gyroy = val; }

  // Calibrated Gyro Z
  void setDataOff_GyroZ(float val) { off_gyroz = val; }

  // Calibrated Accel X
  void setDataOff_AccX(float val) { off_accx = val; }

  // Calibrated Accel Y
  void setDataOff_AccY(float val) { off_accy = val; }

  // Calibrated Accel Z
  void setDataOff_AccZ(float val) { off_accz = val; }

  // Board Tilt Output (us)
  void setDataTiltOut(uint16_t val) { tiltout = val; }

  // Board Roll Output (us)
  void setDataRollOut(uint16_t val) { rollout = val; }

  // Board Pan Output (us)
  void setDataPanOut(uint16_t val) { panout = val; }

  // Has the board been Calibrated
  void setDataIsCal(bool val) { iscal = val; }

  // Bluetooth is connected
  void setDataBtCon(bool val) { btcon = val; }

  // Tilt/Roll/Pan Output Enabled
  void setDataTrpEnabled(bool val) { trpenabled = val; }

  // Raw Tilt in Degrees
  void setDataTilt(float val) { tilt = val; }

  // Raw Roll in Degrees
  void setDataRoll(float val) { roll = val; }

  // Raw Pan in Degrees
  void setDataPan(float val) { pan = val; }

  // Offset Tilt in Degrees
  void setDataTiltOff(float val) { tiltoff = val; }

  // Offset Roll in Degrees
  void setDataRollOff(float val) { rolloff = val; }

  // Offset Pan in Degrees
  void setDataPanOff(float val) { panoff = val; }

  // Gyro Has Been Calibrated
  void setDataGyroCal(bool val) { gyrocal = val; }

  // Channel Outputs
  void setDataChOut(const uint16_t val[16]) {
    memcpy(chout, val, sizeof(uint16_t) * 16);
  }

  // Bluetooth Inputs
  void setDataBtCh(const uint16_t val[8]) {
    memcpy(btch, val, sizeof(uint16_t) * 8);
  }

  // PPM Inputs
  void setDataPpmCh(const uint16_t val[16]) {
    memcpy(ppmch, val, sizeof(uint16_t) * 16);
  }

  // Uart Channels (Sbus/Crsf)
  void setDataUartCh(const uint16_t val[16]) {
    memcpy(uartch, val, sizeof(uint16_t) * 16);
  }

  // Quaternion Output (Tilt / Roll / Pan)
  void setDataQuat(const float val[4]) {
    memcpy(quat, val, sizeof(float) * 4);
  }

  // Local Bluetooth Address
  void setDataBtAddr(const char *val) {
    strncpy(btaddr, val, 18+1);
    btaddr[18] = '\0';
  }

  // Remote Bluetooth Address
  void setDataBtRmt(const char *val) {
    strncpy(btrmt, val, 18+1);
    btrmt[18] = '\0';
  }

  void setJSONSettings(DynamicJsonDocument &json) {
    json["rll_min"] = rll_min;
    json["rll_max"] = rll_max;
    json["rll_cnt"] = rll_cnt;
    json["rll_gain"] = rll_gain;
    json["tlt_min"] = tlt_min;
    json["tlt_max"] = tlt_max;
    json["tlt_cnt"] = tlt_cnt;
    json["tlt_gain"] = tlt_gain;
    json["pan_min"] = pan_min;
    json["pan_max"] = pan_max;
    json["pan_cnt"] = pan_cnt;
    json["pan_gain"] = pan_gain;
    json["tltch"] = tltch;
    json["rllch"] = rllch;
    json["panch"] = panch;
    json["alertch"] = alertch;
    json["pwm0"] = pwm0;
    json["pwm1"] = pwm1;
    json["pwm2"] = pwm2;
    json["pwm3"] = pwm3;
    json["an0ch"] = an0ch;
    json["an1ch"] = an1ch;
    json["an2ch"] = an2ch;
    json["an3ch"] = an3ch;
    json["aux0ch"] = aux0ch;
    json["aux1ch"] = aux1ch;
    json["aux2ch"] = aux2ch;
    json["rstppm"] = rstppm;
    json["aux0func"] = aux0func;
    json["aux1func"] = aux1func;
    json["aux2func"] = aux2func;
    json["an0gain"] = an0gain;
    json["an1gain"] = an1gain;
    json["an2gain"] = an2gain;
    json["an3gain"] = an3gain;
    json["an0off"] = an0off;
    json["an1off"] = an1off;
    json["an2off"] = an2off;
    json["an3off"] = an3off;
    json["servoreverse"] = servoreverse;
    json["magxoff"] = magxoff;
    json["magyoff"] = magyoff;
    json["magzoff"] = magzoff;
    json["accxoff"] = accxoff;
    json["accyoff"] = accyoff;
    json["acczoff"] = acczoff;
    json["gyrxoff"] = gyrxoff;
    json["gyryoff"] = gyryoff;
    json["gyrzoff"] = gyrzoff;
    json["so00"] = so00;
    json["so01"] = so01;
    json["so02"] = so02;
    json["so10"] = so10;
    json["so11"] = so11;
    json["so12"] = so12;
    json["so20"] = so20;
    json["so21"] = so21;
    json["so22"] = so22;
    json["dismag"] = dismag;
    json["rotx"] = rotx;
    json["roty"] = roty;
    json["rotz"] = rotz;
    json["buttonpin"] = buttonpin;
    json["ppmoutpin"] = ppmoutpin;
    json["ppminpin"] = ppminpin;
    json["uartmode"] = uartmode;
    json["crsftxrate"] = crsftxrate;
    json["sbustxrate"] = sbustxrate;
    json["sbininv"] = sbininv;
    json["sboutinv"] = sboutinv;
    json["crsftxinv"] = crsftxinv;
    json["ch5arm"] = ch5arm;
    json["btmode"] = btmode;
    json["rstonwave"] = rstonwave;
    json["butlngps"] = butlngps;
    json["rstontlt"] = rstontlt;
    json["ppmoutinvert"] = ppmoutinvert;
    json["ppmininvert"] = ppmininvert;
    json["ppmframe"] = ppmframe;
    json["ppmsync"] = ppmsync;
    json["ppmchcnt"] = ppmchcnt;
    json["btpairedaddress"] = btpairedaddress;
  }

  void loadJSONSettings(DynamicJsonDocument &json) {
    JsonVariant v;
    bool chpinschanged = false;
    bool chresetfusion = false;
    v = json["rll_min"]; if(!v.isNull()) {setRll_Min(v);}
    v = json["rll_max"]; if(!v.isNull()) {setRll_Max(v);}
    v = json["rll_cnt"]; if(!v.isNull()) {setRll_Cnt(v);}
    v = json["rll_gain"]; if(!v.isNull()) {setRll_Gain(v);}
    v = json["tlt_min"]; if(!v.isNull()) {setTlt_Min(v);}
    v = json["tlt_max"]; if(!v.isNull()) {setTlt_Max(v);}
    v = json["tlt_cnt"]; if(!v.isNull()) {setTlt_Cnt(v);}
    v = json["tlt_gain"]; if(!v.isNull()) {setTlt_Gain(v);}
    v = json["pan_min"]; if(!v.isNull()) {setPan_Min(v);}
    v = json["pan_max"]; if(!v.isNull()) {setPan_Max(v);}
    v = json["pan_cnt"]; if(!v.isNull()) {setPan_Cnt(v);}
    v = json["pan_gain"]; if(!v.isNull()) {setPan_Gain(v);}
    v = json["tltch"]; if(!v.isNull()) {setTltCh(v);}
    v = json["rllch"]; if(!v.isNull()) {setRllCh(v);}
    v = json["panch"]; if(!v.isNull()) {setPanCh(v);}
    v = json["alertch"]; if(!v.isNull()) {setAlertCh(v);}
    v = json["pwm0"]; if(!v.isNull()) {setPwm0(v);}
    v = json["pwm1"]; if(!v.isNull()) {setPwm1(v);}
    v = json["pwm2"]; if(!v.isNull()) {setPwm2(v);}
    v = json["pwm3"]; if(!v.isNull()) {setPwm3(v);}
    v = json["an0ch"]; if(!v.isNull()) {setAn0Ch(v);}
    v = json["an1ch"]; if(!v.isNull()) {setAn1Ch(v);}
    v = json["an2ch"]; if(!v.isNull()) {setAn2Ch(v);}
    v = json["an3ch"]; if(!v.isNull()) {setAn3Ch(v);}
    v = json["aux0ch"]; if(!v.isNull()) {setAux0Ch(v);}
    v = json["aux1ch"]; if(!v.isNull()) {setAux1Ch(v);}
    v = json["aux2ch"]; if(!v.isNull()) {setAux2Ch(v);}
    v = json["rstppm"]; if(!v.isNull()) {setRstPpm(v);}
    v = json["aux0func"]; if(!v.isNull()) {setAux0Func(v);}
    v = json["aux1func"]; if(!v.isNull()) {setAux1Func(v);}
    v = json["aux2func"]; if(!v.isNull()) {setAux2Func(v);}
    v = json["an0gain"]; if(!v.isNull()) {setAn0Gain(v);}
    v = json["an1gain"]; if(!v.isNull()) {setAn1Gain(v);}
    v = json["an2gain"]; if(!v.isNull()) {setAn2Gain(v);}
    v = json["an3gain"]; if(!v.isNull()) {setAn3Gain(v);}
    v = json["an0off"]; if(!v.isNull()) {setAn0Off(v);}
    v = json["an1off"]; if(!v.isNull()) {setAn1Off(v);}
    v = json["an2off"]; if(!v.isNull()) {setAn2Off(v);}
    v = json["an3off"]; if(!v.isNull()) {setAn3Off(v);}
    v = json["servoreverse"]; if(!v.isNull()) {setServoReverse(v);}
    v = json["magxoff"]; if(!v.isNull()) {setMagXOff(v); chresetfusion = true;}
    v = json["magyoff"]; if(!v.isNull()) {setMagYOff(v); chresetfusion = true;}
    v = json["magzoff"]; if(!v.isNull()) {setMagZOff(v); chresetfusion = true;}
    v = json["accxoff"]; if(!v.isNull()) {setAccXOff(v); chresetfusion = true;}
    v = json["accyoff"]; if(!v.isNull()) {setAccYOff(v); chresetfusion = true;}
    v = json["acczoff"]; if(!v.isNull()) {setAccZOff(v); chresetfusion = true;}
    v = json["gyrxoff"]; if(!v.isNull()) {setGyrXOff(v); chresetfusion = true;}
    v = json["gyryoff"]; if(!v.isNull()) {setGyrYOff(v); chresetfusion = true;}
    v = json["gyrzoff"]; if(!v.isNull()) {setGyrZOff(v); chresetfusion = true;}
    v = json["so00"]; if(!v.isNull()) {setso00(v); chresetfusion = true;}
    v = json["so01"]; if(!v.isNull()) {setso01(v); chresetfusion = true;}
    v = json["so02"]; if(!v.isNull()) {setso02(v); chresetfusion = true;}
    v = json["so10"]; if(!v.isNull()) {setso10(v); chresetfusion = true;}
    v = json["so11"]; if(!v.isNull()) {setso11(v); chresetfusion = true;}
    v = json["so12"]; if(!v.isNull()) {setso12(v); chresetfusion = true;}
    v = json["so20"]; if(!v.isNull()) {setso20(v); chresetfusion = true;}
    v = json["so21"]; if(!v.isNull()) {setso21(v); chresetfusion = true;}
    v = json["so22"]; if(!v.isNull()) {setso22(v); chresetfusion = true;}
    v = json["dismag"]; if(!v.isNull()) {setDisMag(v);}
    v = json["rotx"]; if(!v.isNull()) {setRotX(v); chresetfusion = true;}
    v = json["roty"]; if(!v.isNull()) {setRotY(v); chresetfusion = true;}
    v = json["rotz"]; if(!v.isNull()) {setRotZ(v); chresetfusion = true;}
    v = json["buttonpin"]; if(!v.isNull()) {setButtonPin(v); chpinschanged = true;}
    v = json["ppmoutpin"]; if(!v.isNull()) {setPpmOutPin(v); chpinschanged = true;}
    v = json["ppminpin"]; if(!v.isNull()) {setPpmInPin(v); chpinschanged = true;}
    v = json["uartmode"]; if(!v.isNull()) {setUartMode(v);}
    v = json["crsftxrate"]; if(!v.isNull()) {setCrsfTxRate(v);}
    v = json["sbustxrate"]; if(!v.isNull()) {setSbusTxRate(v);}
    v = json["sbininv"]; if(!v.isNull()) {setSbInInv(v); chpinschanged = true;}
    v = json["sboutinv"]; if(!v.isNull()) {setSbOutInv(v);}
    v = json["crsftxinv"]; if(!v.isNull()) {setCrsfTxInv(v);}
    v = json["ch5arm"]; if(!v.isNull()) {setCh5Arm(v);}
    v = json["btmode"]; if(!v.isNull()) {setBtMode(v);}
    v = json["rstonwave"]; if(!v.isNull()) {setRstOnWave(v);}
    v = json["butlngps"]; if(!v.isNull()) {setButLngPs(v);}
    v = json["rstontlt"]; if(!v.isNull()) {setRstOnTlt(v);}
    v = json["ppmoutinvert"]; if(!v.isNull()) {setPpmOutInvert(v);}
    v = json["ppmininvert"]; if(!v.isNull()) {setPpmInInvert(v);}
    v = json["ppmframe"]; if(!v.isNull()) {setPpmFrame(v);}
    v = json["ppmsync"]; if(!v.isNull()) {setPpmSync(v);}
    v = json["ppmchcnt"]; if(!v.isNull()) {setPpmChCnt(v);}
    v = json["btpairedaddress"]; if(!v.isNull()) {setBtPairedAddress(v);}
    if(chpinschanged)
      pinsChanged();
    if(chresetfusion)
      resetFusion();
  }

  void setJSONDataList(DynamicJsonDocument &json)
  {
    JsonArray array = json.createNestedArray();
    array.add("magx");
    array.add("magy");
    array.add("magz");
    array.add("gyrox");
    array.add("gyroy");
    array.add("gyroz");
    array.add("accx");
    array.add("accy");
    array.add("accz");
    array.add("off_magx");
    array.add("off_magy");
    array.add("off_magz");
    array.add("off_gyrox");
    array.add("off_gyroy");
    array.add("off_gyroz");
    array.add("off_accx");
    array.add("off_accy");
    array.add("off_accz");
    array.add("tiltout");
    array.add("rollout");
    array.add("panout");
    array.add("iscal");
    array.add("btcon");
    array.add("trpenabled");
    array.add("tilt");
    array.add("roll");
    array.add("pan");
    array.add("tiltoff");
    array.add("rolloff");
    array.add("panoff");
    array.add("gyrocal");
    array.add("chout");
    array.add("btch");
    array.add("ppmch");
    array.add("uartch");
    array.add("quat");
    array.add("btaddr");
    array.add("btrmt");
  }

  // Sets if a data item should be included while in data to GUI
  void setDataItemSend(const char *var, bool enabled)
  {
    if (strcmp(var, "magx") == 0) {
      enabled == true ? senddatavars |= 1 << 1 : senddatavars &= ~(1 << 1);
      return;
    }
    else if (strcmp(var, "magy") == 0) {
      enabled == true ? senddatavars |= 1 << 2 : senddatavars &= ~(1 << 2);
      return;
    }
    else if (strcmp(var, "magz") == 0) {
      enabled == true ? senddatavars |= 1 << 3 : senddatavars &= ~(1 << 3);
      return;
    }
    else if (strcmp(var, "gyrox") == 0) {
      enabled == true ? senddatavars |= 1 << 4 : senddatavars &= ~(1 << 4);
      return;
    }
    else if (strcmp(var, "gyroy") == 0) {
      enabled == true ? senddatavars |= 1 << 5 : senddatavars &= ~(1 << 5);
      return;
    }
    else if (strcmp(var, "gyroz") == 0) {
      enabled == true ? senddatavars |= 1 << 6 : senddatavars &= ~(1 << 6);
      return;
    }
    else if (strcmp(var, "accx") == 0) {
      enabled == true ? senddatavars |= 1 << 7 : senddatavars &= ~(1 << 7);
      return;
    }
    else if (strcmp(var, "accy") == 0) {
      enabled == true ? senddatavars |= 1 << 8 : senddatavars &= ~(1 << 8);
      return;
    }
    else if (strcmp(var, "accz") == 0) {
      enabled == true ? senddatavars |= 1 << 9 : senddatavars &= ~(1 << 9);
      return;
    }
    else if (strcmp(var, "off_magx") == 0) {
      enabled == true ? senddatavars |= 1 << 10 : senddatavars &= ~(1 << 10);
      return;
    }
    else if (strcmp(var, "off_magy") == 0) {
      enabled == true ? senddatavars |= 1 << 11 : senddatavars &= ~(1 << 11);
      return;
    }
    else if (strcmp(var, "off_magz") == 0) {
      enabled == true ? senddatavars |= 1 << 12 : senddatavars &= ~(1 << 12);
      return;
    }
    else if (strcmp(var, "off_gyrox") == 0) {
      enabled == true ? senddatavars |= 1 << 13 : senddatavars &= ~(1 << 13);
      return;
    }
    else if (strcmp(var, "off_gyroy") == 0) {
      enabled == true ? senddatavars |= 1 << 14 : senddatavars &= ~(1 << 14);
      return;
    }
    else if (strcmp(var, "off_gyroz") == 0) {
      enabled == true ? senddatavars |= 1 << 15 : senddatavars &= ~(1 << 15);
      return;
    }
    else if (strcmp(var, "off_accx") == 0) {
      enabled == true ? senddatavars |= 1 << 16 : senddatavars &= ~(1 << 16);
      return;
    }
    else if (strcmp(var, "off_accy") == 0) {
      enabled == true ? senddatavars |= 1 << 17 : senddatavars &= ~(1 << 17);
      return;
    }
    else if (strcmp(var, "off_accz") == 0) {
      enabled == true ? senddatavars |= 1 << 18 : senddatavars &= ~(1 << 18);
      return;
    }
    else if (strcmp(var, "tiltout") == 0) {
      enabled == true ? senddatavars |= 1 << 19 : senddatavars &= ~(1 << 19);
      return;
    }
    else if (strcmp(var, "rollout") == 0) {
      enabled == true ? senddatavars |= 1 << 20 : senddatavars &= ~(1 << 20);
      return;
    }
    else if (strcmp(var, "panout") == 0) {
      enabled == true ? senddatavars |= 1 << 21 : senddatavars &= ~(1 << 21);
      return;
    }
    else if (strcmp(var, "iscal") == 0) {
      enabled == true ? senddatavars |= 1 << 22 : senddatavars &= ~(1 << 22);
      return;
    }
    else if (strcmp(var, "btcon") == 0) {
      enabled == true ? senddatavars |= 1 << 23 : senddatavars &= ~(1 << 23);
      return;
    }
    else if (strcmp(var, "trpenabled") == 0) {
      enabled == true ? senddatavars |= 1 << 24 : senddatavars &= ~(1 << 24);
      return;
    }
    else if (strcmp(var, "tilt") == 0) {
      enabled == true ? senddatavars |= 1 << 25 : senddatavars &= ~(1 << 25);
      return;
    }
    else if (strcmp(var, "roll") == 0) {
      enabled == true ? senddatavars |= 1 << 26 : senddatavars &= ~(1 << 26);
      return;
    }
    else if (strcmp(var, "pan") == 0) {
      enabled == true ? senddatavars |= 1 << 27 : senddatavars &= ~(1 << 27);
      return;
    }
    else if (strcmp(var, "tiltoff") == 0) {
      enabled == true ? senddatavars |= 1 << 28 : senddatavars &= ~(1 << 28);
      return;
    }
    else if (strcmp(var, "rolloff") == 0) {
      enabled == true ? senddatavars |= 1 << 29 : senddatavars &= ~(1 << 29);
      return;
    }
    else if (strcmp(var, "panoff") == 0) {
      enabled == true ? senddatavars |= 1 << 30 : senddatavars &= ~(1 << 30);
      return;
    }
    else if (strcmp(var, "gyrocal") == 0) {
      enabled == true ? senddatavars |= 1 << 31 : senddatavars &= ~(1 << 31);
      return;
    }
    else if (strcmp(var, "chout") == 0) {
      enabled == true ? senddataarray |= 1 << 1 : senddataarray &= ~(1 << 1);
      return;
    }
    else if (strcmp(var, "btch") == 0) {
      enabled == true ? senddataarray |= 1 << 2 : senddataarray &= ~(1 << 2);
      return;
    }
    else if (strcmp(var, "ppmch") == 0) {
      enabled == true ? senddataarray |= 1 << 3 : senddataarray &= ~(1 << 3);
      return;
    }
    else if (strcmp(var, "uartch") == 0) {
      enabled == true ? senddataarray |= 1 << 4 : senddataarray &= ~(1 << 4);
      return;
    }
    else if (strcmp(var, "quat") == 0) {
      enabled == true ? senddataarray |= 1 << 5 : senddataarray &= ~(1 << 5);
      return;
    }
    else if (strcmp(var, "btaddr") == 0) {
      enabled == true ? senddataarray |= 1 << 6 : senddataarray &= ~(1 << 6);
      return;
    }
    else if (strcmp(var, "btrmt") == 0) {
      enabled == true ? senddataarray |= 1 << 7 : senddataarray &= ~(1 << 7);
      return;
    }
  }

  void sendArray(DynamicJsonDocument &json,
                 uint8_t bit,
                 const uint32_t counter,
                 int divisor,
                 const char *name,
                 void *item,
                 void *lastitem,
                 int size)
  {
    bool sendit = false;
    char b64array[200];
    if (senddataarray & (1 << bit)) {
      if (divisor < 0) {
        if (memcmp(lastitem, item, size) != 0)
          sendit = true;
        else if (divisor != -1 && counter % abs(divisor) == 0)
          sendit = true;
      } else {
        if (counter % divisor == 0)
          sendit = true;
      }
      if (sendit) {
        encode_base64((unsigned char *)item, size, (unsigned char *)b64array);
        json[name] = b64array;
        memcpy(lastitem, item, size);
      }
    }
  }
  
  void setJSONData(DynamicJsonDocument &json)
  {
    // Sends only requested data items
    // Updates only as often as specified, 1 = every cycle
    // Base64 only done on arrays as it ends up on avg more bytes to
    //   do everything

    static uint32_t counter = 0;

    if (senddatavars & (1 << 1) && (counter % 1) == 0)
      json["magx"] = roundf(((float)magx * 1000)) / 1000;
    if (senddatavars & (1 << 2) && (counter % 1) == 0)
      json["magy"] = roundf(((float)magy * 1000)) / 1000;
    if (senddatavars & (1 << 3) && (counter % 1) == 0)
      json["magz"] = roundf(((float)magz * 1000)) / 1000;
    if (senddatavars & (1 << 4) && (counter % 1) == 0)
      json["gyrox"] = roundf(((float)gyrox * 1000)) / 1000;
    if (senddatavars & (1 << 5) && (counter % 1) == 0)
      json["gyroy"] = roundf(((float)gyroy * 1000)) / 1000;
    if (senddatavars & (1 << 6) && (counter % 1) == 0)
      json["gyroz"] = roundf(((float)gyroz * 1000)) / 1000;
    if (senddatavars & (1 << 7) && (counter % 1) == 0)
      json["accx"] = roundf(((float)accx * 1000)) / 1000;
    if (senddatavars & (1 << 8) && (counter % 1) == 0)
      json["accy"] = roundf(((float)accy * 1000)) / 1000;
    if (senddatavars & (1 << 9) && (counter % 1) == 0)
      json["accz"] = roundf(((float)accz * 1000)) / 1000;
    if (senddatavars & (1 << 10) && (counter % 2) == 0)
      json["off_magx"] = roundf(((float)off_magx * 1000)) / 1000;
    if (senddatavars & (1 << 11) && (counter % 2) == 0)
      json["off_magy"] = roundf(((float)off_magy * 1000)) / 1000;
    if (senddatavars & (1 << 12) && (counter % 2) == 0)
      json["off_magz"] = roundf(((float)off_magz * 1000)) / 1000;
    if (senddatavars & (1 << 13) && (counter % 2) == 0)
      json["off_gyrox"] = roundf(((float)off_gyrox * 1000)) / 1000;
    if (senddatavars & (1 << 14) && (counter % 2) == 0)
      json["off_gyroy"] = roundf(((float)off_gyroy * 1000)) / 1000;
    if (senddatavars & (1 << 15) && (counter % 2) == 0)
      json["off_gyroz"] = roundf(((float)off_gyroz * 1000)) / 1000;
    if (senddatavars & (1 << 16) && (counter % 2) == 0)
      json["off_accx"] = roundf(((float)off_accx * 1000)) / 1000;
    if (senddatavars & (1 << 17) && (counter % 2) == 0)
      json["off_accy"] = roundf(((float)off_accy * 1000)) / 1000;
    if (senddatavars & (1 << 18) && (counter % 2) == 0)
      json["off_accz"] = roundf(((float)off_accz * 1000)) / 1000;
    if (senddatavars & (1 << 19) && (counter % 1) == 0)
      json["tiltout"] = tiltout;
    if (senddatavars & (1 << 20) && (counter % 1) == 0)
      json["rollout"] = rollout;
    if (senddatavars & (1 << 21) && (counter % 1) == 0)
      json["panout"] = panout;
    if (senddatavars & (1 << 22) && (counter % 10) == 0)
      json["iscal"] = iscal;
    if (senddatavars & (1 << 23) && (counter % 10) == 0)
      json["btcon"] = btcon;
    if (senddatavars & (1 << 24) && (counter % 10) == 0)
      json["trpenabled"] = trpenabled;
    if (senddatavars & (1 << 25) && (counter % 5) == 0)
      json["tilt"] = roundf(((float)tilt * 1000)) / 1000;
    if (senddatavars & (1 << 26) && (counter % 5) == 0)
      json["roll"] = roundf(((float)roll * 1000)) / 1000;
    if (senddatavars & (1 << 27) && (counter % 5) == 0)
      json["pan"] = roundf(((float)pan * 1000)) / 1000;
    if (senddatavars & (1 << 28) && (counter % 1) == 0)
      json["tiltoff"] = roundf(((float)tiltoff * 1000)) / 1000;
    if (senddatavars & (1 << 29) && (counter % 1) == 0)
      json["rolloff"] = roundf(((float)rolloff * 1000)) / 1000;
    if (senddatavars & (1 << 30) && (counter % 1) == 0)
      json["panoff"] = roundf(((float)panoff * 1000)) / 1000;
    if (senddatavars & (1 << 31) && (counter % 10) == 0)
      json["gyrocal"] = gyrocal;

    sendArray(json,1,counter,1,"6choutu16",(void*)chout,(void*)lastchout, sizeof(uint16_t) * 16);
    sendArray(json,2,counter,1,"6btchu16",(void*)btch,(void*)lastbtch, sizeof(uint16_t) * 8);
    sendArray(json,3,counter,1,"6ppmchu16",(void*)ppmch,(void*)lastppmch, sizeof(uint16_t) * 16);
    sendArray(json,4,counter,1,"6uartchu16",(void*)uartch,(void*)lastuartch, sizeof(uint16_t) * 16);
    sendArray(json,5,counter,1,"6quatflt",(void*)quat,(void*)lastquat, sizeof(float) * 4);
    sendArray(json,6,counter,10,"6btaddrchr",(void*)btaddr,(void*)lastbtaddr, sizeof(char) * 18);
    sendArray(json,7,counter,10,"6btrmtchr",(void*)btrmt,(void*)lastbtrmt, sizeof(char) * 18);

    // Used for reduced data divisor
    counter++;
  }

  void stopAllData()
  {
    senddatavars = 0;
    senddataarray = 0;
  }

protected:
  // Bit map of data to send to GUI, max 64 items
  uint64_t senddatavars;
  uint64_t senddataarray;

  // Settings
  uint16_t rll_min = DEF_MIN_PWM; // Roll Minimum
  uint16_t rll_max = DEF_MAX_PWM; // Roll Maximum
  uint16_t rll_cnt = PPM_CENTER; // Roll Center
  float rll_gain = 5; // Roll Gain
  uint16_t tlt_min = DEF_MIN_PWM; // Tilt Minimum
  uint16_t tlt_max = DEF_MAX_PWM; // Tilt Maximum
  uint16_t tlt_cnt = PPM_CENTER; // Tilt Center
  float tlt_gain = 5; // Tilt Gain
  uint16_t pan_min = DEF_MIN_PWM; // Pan Minimum
  uint16_t pan_max = DEF_MAX_PWM; // Pan Maximum
  uint16_t pan_cnt = PPM_CENTER; // Pan Center
  float pan_gain = 5; // Pan Gain
  int8_t tltch = -1; // Tilt Output Channel
  int8_t rllch = -1; // Roll Output Channel
  int8_t panch = -1; // Pan Output Channel
  int8_t alertch = -1; // Alert Output Channel
  int8_t pwm0 = -1; // PWM 0 Channel
  int8_t pwm1 = -1; // PWM 1 Channel
  int8_t pwm2 = -1; // PWM 2 Channel
  int8_t pwm3 = -1; // PWM 3 Channel
  int8_t an0ch = -1; // Analog 0 Channel
  int8_t an1ch = -1; // Analog 1 Channel
  int8_t an2ch = -1; // Analog 2 Channel
  int8_t an3ch = -1; // Analog 3 Channel
  int8_t aux0ch = -1; // Auxilary Function 0 Channel
  int8_t aux1ch = -1; // Auxilary Function 1 Channel
  int8_t aux2ch = -1; // Auxilary Function 2 Channel
  int8_t rstppm = -1; // Reset Center on PPM Input Channel
  uint8_t aux0func = 0; // Auxilary Function 0
  uint8_t aux1func = 0; // Auxilary Function 1
  uint8_t aux2func = 0; // Auxilary Function 2
  float an0gain = 310; // Analog 0 Gain
  float an1gain = 310; // Analog 1 Gain
  float an2gain = 310; // Analog 2 Gain
  float an3gain = 310; // Analog 3 Gain
  float an0off = 0; // Analog 0 Offset
  float an1off = 0; // Analog 1 Offset
  float an2off = 0; // Analog 2 Offset
  float an3off = 0; // Analog 3 Offset
  uint8_t servoreverse = 0; // Servo Reverse (BitMask)
  float magxoff = 0; // Magnetometer X Calibration Offset
  float magyoff = 0; // Magnetometer Y Calibration Offset
  float magzoff = 0; // Magnetometer Z Calibration Offset
  float accxoff = 0; // Accelerometer X Calibration Offset
  float accyoff = 0; // Accelerometer Y Calibration Offset
  float acczoff = 0; // Accelerometer Z Calibration Offset
  float gyrxoff = 0; // Gyrometer X Calibration Offset
  float gyryoff = 0; // Gyrometer Y Calibration Offset
  float gyrzoff = 0; // Gyrometer Z Calibration Offset
  float so00 = 1; // Soft Iron Offset 00
  float so01 = 0; // Soft Iron Offset 01
  float so02 = 0; // Soft Iron Offset 02
  float so10 = 0; // Soft Iron Offset 10
  float so11 = 1; // Soft Iron Offset 11
  float so12 = 0; // Soft Iron Offset 12
  float so20 = 0; // Soft Iron Offset 20
  float so21 = 0; // Soft Iron Offset 21
  float so22 = 1; // Soft Iron Offset 22
  bool dismag = 1; // Disable Magnetometer
  float rotx = 0; // Board Rotation X
  float roty = 0; // Board Rotation Y
  float rotz = 0; // Board Rotation Z
  int8_t buttonpin = 2; // Button Pin
  int8_t ppmoutpin = 10; // PPM Output Pin
  int8_t ppminpin = -1; // PPM Input Pin
  uint8_t uartmode = 0; // Uart Mode (0- Off, 1-SBUS, 2-CRSFIN, 3-CRSFOUT)
  uint8_t crsftxrate = 140; // CRSF Transmit Frequncy
  uint8_t sbustxrate = 80; // SBUS Transmit Freqency
  bool sbininv = true; // SBUS Receieve Inverted
  bool sboutinv = true; // SBUS Transmit Inverted
  bool crsftxinv = false; // Invert CRSF output
  bool ch5arm = false; // Channel 5 
  uint8_t btmode = 0; // Bluetooth Mode (0-Off, 1- Head, 2-Receive, 3-Scanner)
  bool rstonwave = false; // Reset on Proximity Sense
  bool butlngps = false; // Long Press on the Button to Enable/Disable Tilt Roll and Pan
  bool rstontlt = false; // Reset Center on a Head Tilt
  bool ppmoutinvert = false; // Invert PPM Output
  bool ppmininvert = false; // Invert PPM Output
  uint16_t ppmframe = 22500; // PPM Frame Length (us)
  uint16_t ppmsync = 350; // PPM Sync Pulse Length (us)
  uint8_t ppmchcnt = 8; // PPM channels to output

  // Setting Arrays
  char btpairedaddress[19]; // Bluetooth Remote address to Pair With

  // Real Time Data
  float magx = 0; // Raw Sensor Mag X
  float  magy = 0; // Raw Sensor Mag Y
  float  magz = 0; // Raw Sensor Mag Z
  float gyrox = 0; // Raw Sensor Gyro X
  float gyroy = 0; // Raw Sensor Gyro Y
  float gyroz = 0; // Raw Sensor Gyro Z
  float accx = 0; // Raw Sensor Accel X
  float accy = 0; // Raw Sensor Accel Y
  float accz = 0; // Raw Sensor Accel Z
  float off_magx = 0; // Calibrated Mag X
  float off_magy = 0; // Calibrated Mag Y
  float off_magz = 0; // Calibrated Mag Z
  float off_gyrox = 0; // Calibrated Gyro X
  float off_gyroy = 0; // Calibrated Gyro Y
  float off_gyroz = 0; // Calibrated Gyro Z
  float off_accx = 0; // Calibrated Accel X
  float off_accy = 0; // Calibrated Accel Y
  float off_accz = 0; // Calibrated Accel Z
  uint16_t tiltout = 0; // Board Tilt Output (us)
  uint16_t rollout = 0; // Board Roll Output (us)
  uint16_t panout = 0; // Board Pan Output (us)
  bool iscal = 0; // Has the board been Calibrated
  bool btcon = 0; // Bluetooth is connected
  bool trpenabled = 0; // Tilt/Roll/Pan Output Enabled
  float tilt = 0; // Raw Tilt in Degrees
  float roll = 0; // Raw Roll in Degrees
  float pan = 0; // Raw Pan in Degrees
  float tiltoff = 0; // Offset Tilt in Degrees
  float rolloff = 0; // Offset Roll in Degrees
  float panoff = 0; // Offset Pan in Degrees
  bool gyrocal = 0; // Gyro Has Been Calibrated

  // Real Time Data Arrays
  uint16_t chout[16]; // Channel Outputs
  uint16_t lastchout[16]; // Channel Outputs
  uint16_t btch[8]; // Bluetooth Inputs
  uint16_t lastbtch[8]; // Bluetooth Inputs
  uint16_t ppmch[16]; // PPM Inputs
  uint16_t lastppmch[16]; // PPM Inputs
  uint16_t uartch[16]; // Uart Channels (Sbus/Crsf)
  uint16_t lastuartch[16]; // Uart Channels (Sbus/Crsf)
  float quat[4]; // Quaternion Output (Tilt / Roll / Pan)
  float lastquat[4]; // Quaternion Output (Tilt / Roll / Pan)
  char btaddr[19]; // Local Bluetooth Address
  char lastbtaddr[19]; // Local Bluetooth Address
  char btrmt[19]; // Remote Bluetooth Address
  char lastbtrmt[19]; // Remote Bluetooth Address
};
